import { Database } from "@database";
import { ApiResponses, UploadedXlsxFile, UseFileInterceptor } from "@decorators";
import { BadRequestException, Controller, Get, Post } from "@nestjs/common";
import { parse as parseCsv } from "csv-parse/sync";
import XLSX from "xlsx";
import { UseAuthGuard } from "../auth";
import { XlsxFileDto } from "./dtos";
import { ParseXlsxResult, XlsxFood, XlsxReference } from "./entities";
import { FoodsData, ReferencesData, XlsxService } from "./xlsx.service";
import MeasurementDataType = Database.MeasurementDataType;
const oneHundredMiB = 104_857_600;

const dataTypeToSpanish: Record<MeasurementDataType, string> = {
    [MeasurementDataType.ANALYTIC]: "Analitico",
    [MeasurementDataType.ASSUMED]: "Asumido",
    [MeasurementDataType.BORROWED]: "Prestado",
    [MeasurementDataType.CALCULATED]: "Calculado",
};

@Controller("xlsx")
export class XlsxController {
    
    public constructor(private readonly xlsxService: XlsxService) {
    }

    @Get()
    @UseAuthGuard()
    @ApiResponses({
        ok: {
            description: "XLS(X) file with food and references",
        },
        created: "*Never returned. Automatically generated by Swagger.*",
        badRequest: "Validation errors (body).",
    })
    public async getXlsxV1(codes: string[]): Promise<XLSX.WorkBook> {
        const foods = await this.xlsxService.getFoodsByCodes(codes);
        const headers = [
            "codigo", 
            "nome_es", 
            "ingrediente_esp", 
            "nome_trad portu", 
            "ingrediente_trad", 
            "nome_en", 
            "ingrediente_en", 
            "nome_cientifico_it_a", 
            "nome_cientifico_nit_a",
            "nome_cientifico_it_b",
            "nome_cientifico_nit_b",
            "Variety/Strain",
            "Origin/região",
            "Brand",
            "Group",
            "Tipo_alimento",
            "codigo_langual",
            "Observação",
        ];
        for (let i = 1; i <= 47; i++) {
            headers.push(
                "Promedio",
                "Desviacion", 
                "Minimo",
                "Maximo",
                "n",
                "Codigo/Referencia", 
                "Tipo de dato"
            );
        }
        const foodsCsv: string[][] = [headers]
        ;

        for(const food of foods) {
            const baseRow: string[] = [
                "CLA0001B",
                food.commonName?.es || "",
                food.ingredients?.es || "",
                food.commonName?.pt || "",
                food.ingredients?.pt || "",
                food.commonName?.en || "",
                food.ingredients?.en || "",
                food.scientificName || "",
                food.subspecies || "",
                food.strain || "",
                food.origins?.map(o => o.name).join(", ") || "",
                food.brand || "",
                food.groupCode || "",
                food.typeCode || "",
                food.langualCodes?.map(l => l.code).join("; ") || "",
                food.observation || "",
            ];
            const nutrientData: string[] = [];
            for (let i = 0; i < 47 * 7; i++) {
                nutrientData.push("-");
            }
            if (food.nutrientMeasurements && food.nutrientMeasurements.length > 0) {
                food.nutrientMeasurements.forEach((measurement, index) => {
                    if (index >= 47) return;
                    const baseIndex = index * 7;
                    nutrientData[baseIndex] = measurement.average?.toString() || "-";
                    nutrientData[baseIndex + 1] = measurement.deviation?.toString() || "-";
                    nutrientData[baseIndex + 2] = measurement.min?.toString() || "-";
                    nutrientData[baseIndex + 3] = measurement.max?.toString() || "-";
                    nutrientData[baseIndex + 4] = measurement.sampleSize?.toString() || "-";
                    nutrientData[baseIndex + 5] = measurement.referenceCodes?.join(", ") || "-";
                    nutrientData[baseIndex + 6] = dataTypeToSpanish[measurement.dataType] || "-";
                });
            }
            const fullRow = [...baseRow, ...nutrientData];
            foodsCsv.push(fullRow);

        }
        const workbook = XLSX.utils.book_new();
        const worksheet = XLSX.utils.aoa_to_sheet(foodsCsv);
    
        XLSX.utils.book_append_sheet(workbook, worksheet, "Alimentos");
    
        const excelBuffer = XLSX.write(workbook, { type: 'buffer', bookType: 'xlsx' });

        return excelBuffer ;
    }

    /**
     * Parse the contents of a XLS(X) file into food and reference objects.
     *
     * @remarks Each cell of the file is verified and flagged as `valid`, `new`, and/or `updated`.
     */
    @Post()
    @UseAuthGuard()
    @UseFileInterceptor(XlsxFileDto, "The XLS(X) file.")
    @ApiResponses({
        ok: {
            description: "Parsed XLS(X) file contents successfully.",
            type: ParseXlsxResult,
        },
        created: "*Never returned. Automatically generated by Swagger.*",
        badRequest: "Validation errors (body).",
    })
    public async parseXlsxV1(@UploadedXlsxFile(oneHundredMiB) file: Express.Multer.File): Promise<ParseXlsxResult> {
        const csv = await xlsxToCsv(file);

        const referencesData = await this.xlsxService.getReferencesData();
        const foodsData = await this.xlsxService.getFoodsData();

        const { xlsxReferences, newReferenceCodes } = parseReferences(csv.references.slice(1), referencesData);
        const allReferenceCodes = new Set([...referencesData.codes, ...newReferenceCodes]);
        const xlsxFoods = parseFoods(csv.foods.slice(1), allReferenceCodes, foodsData);

        return {
            foods: xlsxFoods,
            references: xlsxReferences,
        };
    }
}

function parseReferences(csv: string[][], referencesData: ReferencesData): {
    xlsxReferences: XlsxReference[];
    newReferenceCodes: Set<number>;
} {
    const newReferenceCodes = new Set<number>();
    const xlsxReferences: XlsxReference[] = [];

    for (const row of csv) {
        const code = row[0]?.trim() ?? "";

        if (!code) {
            continue;
        }

        const reference = new XlsxReference(row, referencesData);
        xlsxReferences.push(reference);
    }

    return { xlsxReferences, newReferenceCodes };
}

function parseFoods(csv: string[][], allReferenceCodes: Set<number>, dbFoodsData: FoodsData): XlsxFood[] {
    const xlsxFoods: XlsxFood[] = [];

    for (let i = 0; i < csv.length; i += 7) {
        const row = csv[i] ?? [];
        const code = row[0]?.trim() ?? "";

        if (!code) {
            continue;
        }

        const food = new XlsxFood(csv, i, allReferenceCodes, dbFoodsData);
        xlsxFoods.push(food);
    }

    return xlsxFoods;
}
 
async function xlsxToCsv(file: Express.Multer.File): Promise<{
    foods: string[][];
    references: string[][];
}> {
    const wb = XLSX.read(file.buffer, {
        cellFormula: false,
        cellHTML: false,
        sheets: [0, 1],
    });

    const csv = await Promise.all(Object.values(wb.Sheets).map((ws) =>
        XLSX.utils.sheet_to_csv(ws, {
            blankrows: false,
            strip: true,
        })
    ));

    const rawFoods = csv[0]?.replaceAll("\ufeff", "") ?? "";
    const rawReferences = csv[1]?.replaceAll("\ufeff", "") ?? "";

    const foods = parseCsv(rawFoods, {
        relaxColumnCount: true,
        skipEmptyLines: true,
        skipRecordsWithEmptyValues: true,
        trim: true,
    }) as string[][];

    if ((foods[0]?.length ?? 0) < 64) {
        throw new BadRequestException("Foods sheet must have 64 columns");
    }

    const references = parseCsv(rawReferences, {
        relaxColumnCount: true,
        skipEmptyLines: true,
        skipRecordsWithEmptyValues: true,
        trim: true,
    }) as string[][];

    if ((references[0]?.length ?? 0) < 11) {
        throw new BadRequestException("References sheet must have 11 columns");
    }

    return {
        foods,
        references,
    };
}
