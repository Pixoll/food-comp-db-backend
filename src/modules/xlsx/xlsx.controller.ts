import { Database } from "@database";
import { ApiResponses, UploadedXlsxFile, UseFileInterceptor } from "@decorators";
import { BadRequestException, Controller, Get, Post, StreamableFile, Query} from "@nestjs/common";
import { parse as parseCsv } from "csv-parse/sync";
import XLSX from "xlsx";
import { UseAuthGuard } from "../auth";
import { XlsxFileDto, GetXlsxQueryDto} from "./dtos";
import { ParseXlsxResult, XlsxFood, XlsxReference } from "./entities";
import { FoodsData, ReferencesData, XlsxService } from "./xlsx.service";
import MeasurementDataType = Database.MeasurementDataType;
const oneHundredMiB = 104_857_600;

const dataTypeToSpanish: Record<MeasurementDataType, string> = {
    [MeasurementDataType.ANALYTIC]: "Analitico",
    [MeasurementDataType.ASSUMED]: "Asumido",
    [MeasurementDataType.BORROWED]: "Prestado",
    [MeasurementDataType.CALCULATED]: "Calculado",
};

@Controller("xlsx")
export class XlsxController {

    public constructor(private readonly xlsxService: XlsxService) {
    }

    @Get()
    @UseAuthGuard()
    @ApiResponses({
        ok: {
            description: "XLS(X) file with food and references",
            content: {
                "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {},
            },
        },
        created: "*Never returned. Automatically generated by Swagger.*",
        badRequest: "Validation errors (body).",
    })
    
    public async getXlsxV1(@Query() codes: GetXlsxQueryDto): Promise<StreamableFile> {
        
        const foods = await this.xlsxService.getFoodsByCodes(codes.foodCodes);
        const nutrients = await this.xlsxService.getNutrients();
        const referencesMap = new Map();
        foods.forEach(food => {
            if (food.references && Array.isArray(food.references)) {
                food.references.forEach(ref => {
                    if (ref && ref.code) {
                        referencesMap.set(ref.code, ref);
                    }
                });
            }
        });

        const references = Array.from(referencesMap.values());

        const headers = [
            "codigo",
            "nome_esp",
            "ingrediente_esp",
            "nome_trad portu",
            "ingrediente_trad",
            "nome_en",
            "ingrediente_en",
            "nome_cientifico_it_a",
            "nome_cientifico_nit_a",
            "nome_cientifico_it_b",
            "nome_cientifico_nit_b",
            "Variety/Strain",
            "Origin/região",
            "Brand",
            "Group",
            "Tipo_alimento",
            "codigo_langual",
            "Observação",
            "", // espacio entre ambos headers
        ];
        
        const nutrientsMap = new Map<number, number>();
        let indexOfNutrient = headers.length;
        for(const nutrient of nutrients) {
            headers.push(nutrient.name);
            nutrientsMap.set(nutrient.id, indexOfNutrient);
            indexOfNutrient++;
        }
        
        const foodsCsv = [headers];

        const getMeasurementValue = (nutrientData: {
            average: string;
            deviation: string;
            min: string;
            max: string;
            sampleSize: string;
            referenceCodes: string;
            dataType: string;
        } | undefined, measurementIndex: number): string => {
            if (!nutrientData) return "-";
        
            const measurementValues = [
                nutrientData.average,
                nutrientData.deviation,
                nutrientData.min,
                nutrientData.max,
                nutrientData.sampleSize,
                nutrientData.referenceCodes,
                nutrientData.dataType,
            ];
        
            return measurementValues[measurementIndex] || "-";
        };
        
        for (const food of foods) {
            const mainRow: string[] = [
                food.code, // codigo constante
                food.commonName?.es || "",
                food.ingredients?.es || "",
                food.commonName?.pt || "",
                food.ingredients?.pt || "",
                food.commonName?.en || "",
                food.ingredients?.en || "",
                food.scientificName || "",
                food.subspecies || "",
                "",
                "",
                food.strain || "",
                food.origins?.map(o => o.name).join(", ") || "",
                food.brand || "",
                food.groupCode || "",
                food.typeCode || "",
                food.langualCodes?.map(l => l.code).join("; ") || "",
                food.observation || "",
                "", // espacio entre datos y mediciones
            ];
            
            for (let i = 0; i < nutrients.length; i++) {
                mainRow.push("");
            }
            
            foodsCsv.push(mainRow);
        
            const verticalHeaders = [
                "Promedio",
                "Desviacion",
                "Minimo",
                "Maximo",
                "n",
                "Codigo/Referencia",
                "Tipo de dato",
            ];
        
            const nutrientMeasurements = new Map<number, {
                average: string;
                deviation: string;
                min: string;
                max: string;
                sampleSize: string;
                referenceCodes: string;
                dataType: string;
            }>();

            if (food.nutrientMeasurements && food.nutrientMeasurements.length > 0) {
                for (const measurement of food.nutrientMeasurements) {
                    nutrientMeasurements.set(measurement.nutrientId, {
                        average: measurement?.average?.toString() || "-",
                        deviation: measurement?.deviation?.toString() || "-",
                        min: measurement?.min?.toString() || "-",
                        max: measurement?.max?.toString() || "-",
                        sampleSize: measurement?.sampleSize?.toString() || "-",
                        referenceCodes: measurement?.referenceCodes?.map(r => r.toString()).join("; ") || "-",
                        dataType: dataTypeToSpanish[measurement?.dataType] || "-",
                    });
                }
            }

            for (let i = 0; i < verticalHeaders.length; i++) {
                const measurementRow = Array(headers.length - nutrients.length).fill("");
                
                measurementRow[headers.length - nutrients.length - 1] = verticalHeaders[i];
                
                for (const nutrient of nutrients) {
                    const nutrientData = nutrientMeasurements.get(nutrient.id);
                    measurementRow.push(getMeasurementValue(nutrientData, i));
                }
                
                foodsCsv.push(measurementRow);
            }
            
            foodsCsv.push([]);
        }
        const workbook = XLSX.utils.book_new();
        const worksheet1 = XLSX.utils.aoa_to_sheet(foodsCsv);
    
        XLSX.utils.book_append_sheet(workbook, worksheet1, "Alimentos");

        const referencesCsv = [];
        const referenceHeaders = [
            "codigo_de_referencia",
            "autores",
            "titulo",
            "tipo",
            "revista",
            "año_revista",
            "numero",
            "pagina",
            "ciudad",
            "año/tesis",
            "otro",
        ];
        
        referencesCsv.push(referenceHeaders);
        
        for (const reference of references) {
            const referenceRow = [
                reference.code?.toString() || "",
                reference.authors?.join(", ") || "",
                reference.title || "",
                reference.type || "",
                reference.journalName || "",
                reference.volumeYear?.toString() || "",
                reference.issue?.toString() || "",
                reference.pageStart && reference.pageEnd ? `${reference.pageStart} - ${reference.pageEnd}` : "",
                reference.city || "",
                reference.year?.toString() || "",
                reference.other || "",
            ];
            referencesCsv.push(referenceRow);
        }
        
        const worksheet2 = XLSX.utils.aoa_to_sheet(referencesCsv);
        XLSX.utils.book_append_sheet(workbook, worksheet2, "Referencias");

        const excelBuffer = XLSX.write(workbook, { type: "buffer", bookType: "xlsx" });

        return new StreamableFile(excelBuffer, { type: "excel mime typ" });    }

    /**
     * Parse the contents of a XLS(X) file into food and reference objects.
     *
     * @remarks Each cell of the file is verified and flagged as `valid`, `new`, and/or `updated`.
     */
    @Post()
    @UseAuthGuard()
    @UseFileInterceptor(XlsxFileDto, "The XLS(X) file.")
    @ApiResponses({
        ok: {
            description: "Parsed XLS(X) file contents successfully.",
            type: ParseXlsxResult,
        },
        created: "*Never returned. Automatically generated by Swagger.*",
        badRequest: "Validation errors (body).",
    })
    public async parseXlsxV1(@UploadedXlsxFile(oneHundredMiB) file: Express.Multer.File): Promise<ParseXlsxResult> {
        const csv = await xlsxToCsv(file);

        const referencesData = await this.xlsxService.getReferencesData();
        const foodsData = await this.xlsxService.getFoodsData();

        const { xlsxReferences, newReferenceCodes } = parseReferences(csv.references.slice(1), referencesData);
        const allReferenceCodes = new Set([...referencesData.codes, ...newReferenceCodes]);
        const xlsxFoods = parseFoods(csv.foods.slice(1), allReferenceCodes, foodsData);

        return {
            foods: xlsxFoods,
            references: xlsxReferences,
        };
    }
}

function parseReferences(csv: string[][], referencesData: ReferencesData): {
    xlsxReferences: XlsxReference[];
    newReferenceCodes: Set<number>;
} {
    const newReferenceCodes = new Set<number>();
    const xlsxReferences: XlsxReference[] = [];

    for (const row of csv) {
        const code = row[0]?.trim() ?? "";

        if (!code) {
            continue;
        }

        const reference = new XlsxReference(row, referencesData);
        xlsxReferences.push(reference);
    }

    return { xlsxReferences, newReferenceCodes };
}

function parseFoods(csv: string[][], allReferenceCodes: Set<number>, dbFoodsData: FoodsData): XlsxFood[] {
    const xlsxFoods: XlsxFood[] = [];

    for (let i = 0; i < csv.length; i += 7) {
        const row = csv[i] ?? [];
        const code = row[0]?.trim() ?? "";

        if (!code) {
            continue;
        }

        const food = new XlsxFood(csv, i, allReferenceCodes, dbFoodsData);
        xlsxFoods.push(food);
    }

    return xlsxFoods;
}
 
async function xlsxToCsv(file: Express.Multer.File): Promise<{
    foods: string[][];
    references: string[][];
}> {
    const wb = XLSX.read(file.buffer, {
        cellFormula: false,
        cellHTML: false,
        sheets: [0, 1],
    });

    const csv = await Promise.all(Object.values(wb.Sheets).map((ws) =>
        XLSX.utils.sheet_to_csv(ws, {
            blankrows: false,
            strip: true,
        })
    ));

    const rawFoods = csv[0]?.replaceAll("\ufeff", "") ?? "";
    const rawReferences = csv[1]?.replaceAll("\ufeff", "") ?? "";

    const foods = parseCsv(rawFoods, {
        relaxColumnCount: true,
        skipEmptyLines: true,
        skipRecordsWithEmptyValues: true,
        trim: true,
    }) as string[][];

    if ((foods[0]?.length ?? 0) < 64) {
        throw new BadRequestException("Foods sheet must have 64 columns");
    }

    const references = parseCsv(rawReferences, {
        relaxColumnCount: true,
        skipEmptyLines: true,
        skipRecordsWithEmptyValues: true,
        trim: true,
    }) as string[][];

    if ((references[0]?.length ?? 0) < 11) {
        throw new BadRequestException("References sheet must have 11 columns");
    }

    return {
        foods,
        references,
    };
}
