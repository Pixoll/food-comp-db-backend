import { ApiResponses } from "@decorators";
import { Body, Controller, Post, Version } from "@nestjs/common";
import { UseAuthGuard } from "../auth";
import { CsvService, FoodsData, ReferencesData } from "./csv.service";
import { CsvBodyDto } from "./dtos";
import { CsvFood, CsvReference, ParseCsvResult } from "./entities";

@Controller("csv")
export class CsvController {
    public constructor(private readonly csvService: CsvService) {
    }

    /**
     * Parse the contents of a CSV file into food and reference objects.
     *
     * @remarks Each cell of the CSV is verified and flagged as `valid`, `new`, and/or `updated`.
     */
    @Version("1")
    @Post()
    @UseAuthGuard()
    @ApiResponses({
        ok: {
            description: "Parsed CSV file contents successfully.",
            type: ParseCsvResult,
        },
        created: "*Never returned. Automatically generated by Swagger.*",
        badRequest: "Validation errors (body).",
    })
    public async parseCsvV1(@Body() body: CsvBodyDto): Promise<ParseCsvResult> {
        const csv = body.parse();

        const referencesData = await this.csvService.getReferencesData();
        const foodsData = await this.csvService.getFoodsData();

        const { csvReferences, newReferenceCodes } = parseReferences(csv.references.slice(1), referencesData);

        const allReferenceCodes = new Set([...referencesData.codes, ...newReferenceCodes]);

        const { csvFoods, foodCodes } = parseFoods(csv.foods.slice(1), allReferenceCodes, foodsData);
        const dbFoods = await this.csvService.getDBFoods([...foodCodes]);

        for (const food of csvFoods) {
            food.updateFlags(dbFoods);
        }

        return {
            foods: csvFoods,
            references: csvReferences,
        };
    }
}

function parseReferences(csv: string[][], referencesData: ReferencesData): {
    csvReferences: CsvReference[];
    newReferenceCodes: Set<number>;
} {
    const newReferenceCodes = new Set<number>();
    const csvReferences: CsvReference[] = [];

    for (const row of csv) {
        const code = row[0]?.trim() ?? "";

        if (!code) {
            continue;
        }

        const reference = new CsvReference(row, referencesData);
        csvReferences.push(reference);
    }

    return { csvReferences, newReferenceCodes };
}

function parseFoods(csv: string[][], allReferenceCodes: Set<number>, dbFoodsData: FoodsData): {
    csvFoods: CsvFood[];
    foodCodes: Set<string>;
} {
    const foodCodes = new Set<string>();
    const csvFoods: CsvFood[] = [];

    for (let i = 0; i < csv.length; i += 7) {
        const csvRow = csv[i] ?? [];
        const code = csvRow[0]?.trim() ?? "";

        if (!code) {
            continue;
        }

        const food = new CsvFood(csv, i, allReferenceCodes, dbFoodsData);

        if (food.code.parsed) {
            foodCodes.add(food.code.parsed.toUpperCase());
        }

        csvFoods.push(food);
    }

    return { csvFoods, foodCodes };
}
