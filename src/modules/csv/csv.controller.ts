import { ApiResponses, UploadedXlsxFile } from "@decorators";
import { BadRequestException, Controller, Post, UseInterceptors, Version } from "@nestjs/common";
import { FileInterceptor } from "@nestjs/platform-express";
import { parse as parseCsv } from "csv-parse/sync";
import XLSX from "xlsx";
import { UseAuthGuard } from "../auth";
import { CsvService, FoodsData, ReferencesData } from "./csv.service";
import { CsvFood, CsvReference, ParseCsvResult } from "./entities";

const oneHundredMiB = 104_857_600;

@Controller("csv")
export class CsvController {
    public constructor(private readonly csvService: CsvService) {
    }

    /**
     * Parse the contents of a CSV file into food and reference objects.
     *
     * @remarks Each cell of the CSV is verified and flagged as `valid`, `new`, and/or `updated`.
     */
    @Version("1")
    @Post()
    @UseAuthGuard()
    @UseInterceptors(FileInterceptor("file"))
    @ApiResponses({
        ok: {
            description: "Parsed CSV file contents successfully.",
            type: ParseCsvResult,
        },
        created: "*Never returned. Automatically generated by Swagger.*",
        badRequest: "Validation errors (body).",
    })
    public async parseCsvV1(@UploadedXlsxFile(oneHundredMiB) file: Express.Multer.File): Promise<ParseCsvResult> {
        const csv = await parseXlsxFile(file);

        const referencesData = await this.csvService.getReferencesData();
        const foodsData = await this.csvService.getFoodsData();

        const { csvReferences, newReferenceCodes } = parseReferences(csv.references.slice(1), referencesData);

        const allReferenceCodes = new Set([...referencesData.codes, ...newReferenceCodes]);

        const { csvFoods, foodCodes } = parseFoods(csv.foods.slice(1), allReferenceCodes, foodsData);
        const dbFoods = await this.csvService.getDBFoods([...foodCodes]);

        for (const food of csvFoods) {
            food.updateFlags(dbFoods);
        }

        return {
            foods: csvFoods,
            references: csvReferences,
        };
    }
}

function parseReferences(csv: string[][], referencesData: ReferencesData): {
    csvReferences: CsvReference[];
    newReferenceCodes: Set<number>;
} {
    const newReferenceCodes = new Set<number>();
    const csvReferences: CsvReference[] = [];

    for (const row of csv) {
        const code = row[0]?.trim() ?? "";

        if (!code) {
            continue;
        }

        const reference = new CsvReference(row, referencesData);
        csvReferences.push(reference);
    }

    return { csvReferences, newReferenceCodes };
}

function parseFoods(csv: string[][], allReferenceCodes: Set<number>, dbFoodsData: FoodsData): {
    csvFoods: CsvFood[];
    foodCodes: Set<string>;
} {
    const foodCodes = new Set<string>();
    const csvFoods: CsvFood[] = [];

    for (let i = 0; i < csv.length; i += 7) {
        const csvRow = csv[i] ?? [];
        const code = csvRow[0]?.trim() ?? "";

        if (!code) {
            continue;
        }

        const food = new CsvFood(csv, i, allReferenceCodes, dbFoodsData);

        if (food.code.parsed) {
            foodCodes.add(food.code.parsed.toUpperCase());
        }

        csvFoods.push(food);
    }

    return { csvFoods, foodCodes };
}

async function parseXlsxFile(file: Express.Multer.File): Promise<CsvTables> {
    const wb = XLSX.read(file.buffer, {
        cellFormula: false,
        cellHTML: false,
    });

    const csv = await Promise.all(
        Object.values(wb.Sheets).map((ws) =>
            XLSX.utils.sheet_to_csv(ws, {
                blankrows: false,
                strip: true,
            })
        )
    );

    const rawFoods = csv[0]?.replaceAll("\ufeff", "") ?? "";
    const rawReferences = csv[1]?.replaceAll("\ufeff", "") ?? "";

    const foods = parseCsv(rawFoods, {
        relaxColumnCount: true,
        skipEmptyLines: true,
        skipRecordsWithEmptyValues: true,
        trim: true,
    }) as string[][];

    if ((foods[0]?.length ?? 0) < 64) {
        throw new BadRequestException("Foods CSV must have 64 columns");
    }

    const references = parseCsv(rawReferences, {
        relaxColumnCount: true,
        skipEmptyLines: true,
        skipRecordsWithEmptyValues: true,
        trim: true,
    }) as string[][];

    if ((references[0]?.length ?? 0) < 11) {
        throw new BadRequestException("References CSV must have 11 columns");
    }

    return {
        foods,
        references,
    };
}

type CsvTables = {
    foods: string[][];
    references: string[][];
};
